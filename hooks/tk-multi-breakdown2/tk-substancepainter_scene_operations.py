# Copyright 2025 Donat Van Bellinghen
#
# Inspired by original work by Diego Garcia Huerta (2019)

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Your use of the Flow Production Tracking Pipeline Toolkit is governed by the applicable
# license agreement between you and Autodesk.

__author__ = "Donat Van Bellinghen"
__contact__ = "https://www.linkedin.com/in/donat-van-bellinghen-98002914/"
__credits__ = ["Diego Garcia Huerta", "Donat Van Bellinghen"]


import os

import sgtk
import substance_painter as sp

HookBaseClass = sgtk.get_hook_baseclass()

logger = sgtk.platform.get_logger(__name__)


class BreakdownSceneOperations(HookBaseClass):
    """
    Breakdown operations for Substance Painter.

    """

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.

        The return data structure is a list of dictionaries. Each scene reference
        that is returned should be represented by a dictionary with three keys:

        - "node_name": The name of the 'node' that is to be operated on. Most DCCs have
          a concept of a node, path or some other way to address a particular
          object in the scene.
        - "node_type": The object type that this is. This is later passed to the
          update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.
        - "extra_data": Optional key to pass some extra data to the update method
          in case we'd like to access them when updating the nodes.

        Toolkit will scan the list of items, see if any of the objects matches
        a published file and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.
        """


        engine = self.parent.engine

        items = []

        # get the path to the current mesh
        mesh_path = sp.project.last_imported_mesh_path()
        mesh_path = engine.convert_mapped_drive_path_to_unc_path(mesh_path)
        mesh_path = os.path.normpath(mesh_path)

        items.append(
            {
                "node_name": os.path.basename(mesh_path),
                "node_type": "mesh",
                "path": mesh_path,
            }
        )

        return items

    def update(self, item):
        """
        Perform replacements given a number of scene items passed from the app.

        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.

        :param item: Dictionary on the same form as was generated by the scan_scene hook above.
                     The path key now holds the path that the node should be updated *to* rather than the current path.
        """
        engine = self.parent.engine

        node_name = item["node_name"]
        node_type = item["node_type"]
        path = item["path"]
        path = engine.convert_unc_path_to_mapped_drive_path(path)

        if node_type == "mesh":
            mesh_reloading_settings = sp.project.MeshReloadingSettings(
                import_cameras=False, preserve_strokes=True
            )
            # Replace the mesh:
            sp.project.reload_mesh(path, mesh_reloading_settings, self.on_mesh_reload)

    # Function that will be called when reloading is finished:
    @staticmethod
    def on_mesh_reload(status: sp.project.ReloadMeshStatus):
        if status == sp.project.ReloadMeshStatus.SUCCESS:
            logger.debug("ShotGrid: The mesh was replaced successfully.")
        else:
            logger.error("ShotGrid: The mesh couldn't be replaced.")
